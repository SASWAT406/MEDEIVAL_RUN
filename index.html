<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Medieval Knight: The Never Ending Run</title>
    <style>
        /* DISABLE SCROLLING ON MOBILE */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #050510; 
            font-family: 'Courier New', serif; 
            touch-action: none; /* Critical for mobile games */
            user-select: none;
            -webkit-user-select: none;
        }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD - Made slightly larger for mobile readability */
        #run-score-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(-140px);
            color: #ffffff; font-size: 20px; font-weight: bold;
            text-shadow: 0 0 5px #ffffff;
            background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 5px;
            border-left: 3px solid #e74c3c;
        }

        #diamond-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(20px);
            color: #00ffff; font-size: 20px; font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
            background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 5px;
            border-right: 3px solid #00ffff;
        }

        /* BUTTONS - Larger touch targets */
        .hud-btn {
            position: absolute; top: 20px;
            background: #8e44ad; color: white; border: 2px solid #fff;
            width: 50px; height: 50px; border-radius: 50%;
            font-size: 24px; font-weight: bold; cursor: pointer;
            pointer-events: auto; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 10px rgba(142, 68, 173, 0.8);
            transition: transform 0.1s;
        }
        .hud-btn:active { transform: scale(0.9); background: #9b59b6; }

        #pause-btn { left: 20px; }
        #music-btn { right: 20px; font-size: 24px; background: #2c3e50; border-color: #95a5a6; }

        /* SCREENS */
        #menu-screen, #pause-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 10; text-align: center;
        }

        #pause-screen { display: none; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); }

        h1 { color: #e74c3c; font-size: 50px; margin: 0; text-transform: uppercase; letter-spacing: 3px; text-shadow: 0 0 20px #e74c3c; }
        h2 { color: #888; font-size: 16px; margin-bottom: 20px; font-style: italic; }
        
        .controls { color: #ddd; margin-bottom: 20px; font-size: 16px; line-height: 1.6; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; max-width: 80%; }
        .key { color: #ffd700; font-weight: bold; }

        .btn-main {
            background: #8e44ad; color: #fff; border: 2px solid #e74c3c;
            padding: 15px 50px; font-size: 22px; cursor: pointer;
            text-transform: uppercase; font-weight: bold; box-shadow: 0 0 15px #e74c3c;
            margin-top: 10px; transition: transform 0.1s;
            border-radius: 8px;
        }
        .btn-main:active { background: #9b59b6; transform: scale(0.95); }
        
        .stats-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            margin-bottom: 30px; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;
        }
        .stat-item { font-size: 18px; color: #fff; text-align: left; }
        .stat-val { font-weight: bold; color: #ffd700; float: right; }

        #game-over-title { display: none; color: red; font-size: 40px; font-weight: bold; margin-bottom: 20px; text-shadow: 0 0 20px red; }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <button id="pause-btn" class="hud-btn" onclick="togglePause()">||</button>
    <button id="music-btn" class="hud-btn" onclick="toggleMusic()">♫</button>

    <div id="ui-layer">
        <div id="run-score-box">SCORE: <span id="run-score-val">0</span></div>
        <div id="diamond-box">DIAMOND: <span id="diamond-val">0</span></div>

        <div id="pause-screen">
            <h1>PAUSED</h1>
            <button class="btn-main" onclick="togglePause()">RESUME</button>
        </div>

        <div id="menu-screen">
            <div id="game-over-title">THE PHANTOM CAUGHT YOU!</div>
            <h1 id="main-title">Dungeon Run</h1>
            <h2 id="sub-title">Mobile War Edition</h2>
            <div id="results-panel" style="display:none;" class="stats-grid">
                <div class="stat-item">Distance: <span id="final-run-score" class="stat-val">0</span></div>
                <div class="stat-item">Diamonds: <span id="final-diamond-score" class="stat-val">0</span></div>
            </div>
            <div id="controls-panel" class="controls">
                <span class="key">SWIPE UP</span> to Jump<br>
                <span class="key">SWIPE DOWN</span> to Slide<br>
                <span class="key">SWIPE LEFT/RIGHT</span> to Move
            </div>
            <button id="start-btn" class="btn-main" onclick="startGame()">ENTER DUNGEON</button>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const CONFIG = {
            laneWidth: 4.0,
            startSpeed: 0.35,  
            maxSpeed: 0.95,    
            jumpForce: 0.72,
            gravity: 0.038,
            fogColor: 0x151530, 
            chaserStartZ: 6,
            chaserFarZ: 35
        };

        // --- 2. VARIABLES ---
        var scene, camera, renderer;
        var playerGroup, chaserGroup;
        var limbs = {};
        var obstacles = [];
        var coins = [];
        var floorSegments = [];
        var torches = []; 
        var isPlaying = false;
        var isGameOver = false;
        var isPaused = false;
        
        var runScore = 0;      
        var diamondScore = 0;  
        var gameSpeed = CONFIG.startSpeed;
        var frameCount = 0;

        var currentLane = 0;
        var playerY = 0;
        var verticalVel = 0;
        var isJumping = false;
        var isSliding = false;
        var slideTimer = 0;

        var chaserOffset = CONFIG.chaserStartZ;
        var chaserTarget = CONFIG.chaserStartZ;

        // AUDIO GLOBALS
        var audioCtx;
        var masterGain;
        var nextNoteTime = 0;
        var beatIndex = 0;
        var isMuted = false;
        var noiseBuffer;

        window.onload = function() { init(); };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.fogColor);
            scene.fog = new THREE.Fog(CONFIG.fogColor, 15, 90);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 6, -12);
            camera.lookAt(0, 2, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createMaterials();
            setupLighting();
            createKnight();
            createChaser();

            for(var i=-2; i<8; i++) spawnFloor(i * 100);

            // CONTROLS
            document.addEventListener('keydown', handleKey);
            setupTouchControls(); // NEW TOUCH CONTROLS
            window.addEventListener('resize', onResize);
            
            animate();
        }

        // --- 3. TOUCH CONTROLS (NEW) ---
        function setupTouchControls() {
            var touchStartX = 0;
            var touchStartY = 0;

            document.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, false);

            document.addEventListener('touchend', function(e) {
                if(!isPlaying || isPaused) return;

                var touchEndX = e.changedTouches[0].screenX;
                var touchEndY = e.changedTouches[0].screenY;

                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, false);
        }

        function handleSwipe(sx, sy, ex, ey) {
            var dx = ex - sx;
            var dy = ey - sy;

            // Determine if horizontal or vertical swipe
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal
                if (Math.abs(dx) > 30) { // Threshold
                    if (dx > 0 && currentLane > -1) currentLane--; // Swipe Right
                    if (dx < 0 && currentLane < 1) currentLane++; // Swipe Left
                }
            } else {
                // Vertical
                if (Math.abs(dy) > 30) { // Threshold
                    if (dy < 0 && !isJumping) verticalVel = CONFIG.jumpForce; // Swipe Up
                    if (dy > 0 && !isJumping && !isSliding) { // Swipe Down
                        isSliding = true; 
                        slideTimer = 40;
                    }
                }
            }
        }

        // --- 4. AUDIO ENGINE ---
        function initAudio() {
            if (audioCtx) return;
            var AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
            
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.4;
            masterGain.connect(audioCtx.destination);

            var bufferSize = audioCtx.sampleRate * 2; 
            noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var data = noiseBuffer.getChannelData(0);
            for (var i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            nextNoteTime = audioCtx.currentTime;
            scheduler();
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + 0.1) {
                if(isPlaying && !isPaused && !isGameOver) {
                    playBeat(nextNoteTime, beatIndex);
                    nextNoteTime += 0.12; 
                    beatIndex = (beatIndex + 1) % 16;
                } else {
                    nextNoteTime += 0.1;
                }
            }
            setTimeout(scheduler, 25);
        }

        function playBeat(time, beat) {
            if(isMuted) return;
            var kicks = [0, 3, 4, 7, 8, 11, 12, 15];
            if (kicks.includes(beat)) playKick(time);
            if (beat === 4 || beat === 12) playSnare(time);
            if (beat % 2 === 0) playBass(time, 55);
            var notes = [293.66, 329.63, 349.23, 392.00, 440.00, 466.16, 554.37]; 
            if (beat % 4 === 0 && Math.random() > 0.3) {
                var note = notes[Math.floor(Math.random() * notes.length)];
                playHorn(time, note);
            }
        }

        function playKick(time) {
            var osc = audioCtx.createOscillator();
            var gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(120, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.1);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(time);
            osc.stop(time + 0.1);
        }

        function playSnare(time) {
            var src = audioCtx.createBufferSource();
            src.buffer = noiseBuffer;
            var filter = audioCtx.createBiquadFilter();
            filter.type = "highpass";
            filter.frequency.value = 1000;
            var gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            src.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            src.start(time);
            src.stop(time + 0.1);
        }

        function playBass(time, freq) {
            var osc = audioCtx.createOscillator();
            osc.type = "sawtooth";
            osc.frequency.setValueAtTime(freq, time);
            var filter = audioCtx.createBiquadFilter();
            filter.type = "lowpass";
            filter.frequency.setValueAtTime(400, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.1);
            var gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            osc.start(time);
            osc.stop(time + 0.2);
        }

        function playHorn(time, freq) {
            var osc = audioCtx.createOscillator();
            osc.type = "sawtooth"; 
            osc.frequency.setValueAtTime(freq, time);
            osc.detune.value = Math.random() * 10 - 5;
            var gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.3, time + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(time);
            osc.stop(time + 0.4);
        }

        function toggleMusic() {
            isMuted = !isMuted;
            var btn = document.getElementById('music-btn');
            if(isMuted) {
                if(masterGain) masterGain.gain.value = 0;
                btn.style.opacity = "0.5";
                btn.innerText = "✕";
            } else {
                if(masterGain) masterGain.gain.value = 0.4;
                btn.style.opacity = "1";
                btn.innerText = "♫";
            }
        }

        // --- GRAPHICS ---
        var MAT = {};
        function createMaterials() {
            MAT.armor = new THREE.MeshLambertMaterial({ color: 0xffffff });
            MAT.dark = new THREE.MeshLambertMaterial({ color: 0x444444 });
            MAT.red = new THREE.MeshBasicMaterial({ color: 0xee0000 });
            MAT.wood = new THREE.MeshLambertMaterial({ color: 0x8d5e42 });
            MAT.brokenWood = new THREE.MeshLambertMaterial({ color: 0x6b4533 });
            MAT.stone = new THREE.MeshLambertMaterial({ color: 0x666666 });
            MAT.bone = new THREE.MeshLambertMaterial({ color: 0xffffff }); 
            MAT.fire = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            MAT.ghost = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 });
            MAT.glow = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            MAT.diamond = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            MAT.iron = new THREE.MeshLambertMaterial({ color: 0x333333 });
        }

        function setupLighting() {
            var ambient = new THREE.AmbientLight(0x666688, 1.2);
            scene.add(ambient);
            var playerLight = new THREE.PointLight(0xffaa00, 2.0, 35);
            playerLight.position.set(0, 5, 5);
            camera.add(playerLight); 
            scene.add(camera);
            var rimLight = new THREE.DirectionalLight(0x8888ff, 0.8);
            rimLight.position.set(0, 10, -20);
            scene.add(rimLight);
        }

        function createKnight() {
            playerGroup = new THREE.Group();
            var torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.6), MAT.armor);
            torso.position.y = 1.4; playerGroup.add(torso);
            var head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), MAT.armor);
            head.position.y = 2.5; playerGroup.add(head);
            var plume = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.4), MAT.red);
            plume.position.set(0, 3.0, -0.2); playerGroup.add(plume);
            function makeLimb(x, y, mat) {
                var g = new THREE.Group(); g.position.set(x, y, 0);
                var m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.3), mat);
                m.position.y = -0.5; g.add(m); return g;
            }
            limbs.armL = makeLimb(-0.7, 2.0, MAT.armor); playerGroup.add(limbs.armL);
            limbs.armR = makeLimb(0.7, 2.0, MAT.armor); playerGroup.add(limbs.armR);
            limbs.legL = makeLimb(-0.3, 0.8, MAT.dark); playerGroup.add(limbs.legL);
            limbs.legR = makeLimb(0.3, 0.8, MAT.dark); playerGroup.add(limbs.legR);
            scene.add(playerGroup);
        }

        function createChaser() {
            chaserGroup = new THREE.Group();
            var body = new THREE.Mesh(new THREE.ConeGeometry(1.5, 4, 8), MAT.ghost);
            body.position.y = 2.5; chaserGroup.add(body);
            var head = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), MAT.ghost);
            head.position.y = 4.0; chaserGroup.add(head);
            var eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.12), MAT.glow);
            eyeL.position.set(-0.3, 4.0, 0.6); chaserGroup.add(eyeL);
            var eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.12), MAT.glow);
            eyeR.position.set(0.3, 4.0, 0.6); chaserGroup.add(eyeR);
            scene.add(chaserGroup);
        }

        // --- OBJECTS ---
        function createSkull() {
            var g = new THREE.Group();
            var head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 6, 6), MAT.bone); g.add(head);
            var jaw = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.3), MAT.bone); jaw.position.y = -0.35; g.add(jaw);
            var eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.05), MAT.dark); eyeL.position.set(-0.12, 0, 0.3); g.add(eyeL);
            var eyeR = eyeL.clone(); eyeR.position.set(0.12, 0, 0.3); g.add(eyeR);
            return g;
        }
        function createWallTorch() {
            var g = new THREE.Group();
            var stick = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8), MAT.wood);
            stick.rotation.x = Math.PI / 4; stick.position.z = 0.4; g.add(stick);
            var flame = new THREE.Mesh(new THREE.DodecahedronGeometry(0.2), MAT.fire);
            flame.position.set(0, 0.3, 0.7); g.add(flame);
            torches.push({ mesh: flame, offset: Math.random() * 10 });
            return g;
        }
        function createBrokenCart() {
            var g = new THREE.Group();
            var base = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.4, 5.0), MAT.brokenWood);
            base.position.y = 0.5; base.rotation.z = (Math.random()-0.5)*0.4; base.rotation.y = (Math.random()-0.5)*0.2; g.add(base);
            var p1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 4.5), MAT.wood); p1.position.set(-1.4, 1.2, 0); p1.rotation.z = -0.2; g.add(p1);
            var p2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.0, 4.5), MAT.wood); p2.position.set(1.4, 1.0, 0); p2.rotation.z = 0.3; g.add(p2);
            for(var k=0; k<3; k++) {
                var d = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 1.5), MAT.wood); d.position.set((Math.random()-0.5)*2, 0.6, (Math.random()-0.5)*4); d.rotation.set(Math.random(),Math.random(),Math.random()); g.add(d);
            }
            var wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16); wGeo.rotateZ(Math.PI/2);
            var w1 = new THREE.Mesh(wGeo, MAT.iron); w1.position.set(-1.6, 0.8, 1.5); g.add(w1);
            var w2 = new THREE.Mesh(wGeo, MAT.iron); w2.position.set(2.0, 0.4, -1.0); w2.rotation.x = Math.PI/2; w2.rotation.z = Math.random(); g.add(w2);
            return g;
        }
        function createLog() {
            var g = new THREE.Group();
            var m = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 3.5, 8), MAT.wood);
            m.rotation.z = Math.PI/2; m.position.y = 0.5; g.add(m);
            return g;
        }
        function createBeam() {
            var g = new THREE.Group();
            var top = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.6, 0.6), MAT.wood);
            top.position.y = 2.4; g.add(top);
            var l1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 3, 0.4), MAT.wood);
            l1.position.set(-1.7, 1.5, 0); g.add(l1);
            var l2 = l1.clone(); l2.position.set(1.7, 1.5, 0); g.add(l2);
            return g;
        }

        // --- LEVEL ---
        function spawnFloor(zPos) {
            var g = new THREE.Group();
            var road = new THREE.Mesh(new THREE.PlaneGeometry(30, 100), new THREE.MeshLambertMaterial({color:0x3e2e22}));
            road.rotation.x = -Math.PI/2; g.add(road);
            var wallGeo = new THREE.BoxGeometry(2, 10, 20);
            for(var i=0; i<5; i++) {
                var z = (i*20) - 40;
                var w1 = new THREE.Mesh(wallGeo, MAT.stone); w1.position.set(-16, 5, z); g.add(w1);
                var w2 = new THREE.Mesh(wallGeo, MAT.stone); w2.position.set(16, 5, z); g.add(w2);
                if(i % 2 === 0) {
                    var tL = createWallTorch(); tL.position.set(-14.8, 6, z); tL.rotation.y = Math.PI/2; g.add(tL);
                    var tR = createWallTorch(); tR.position.set(14.8, 6, z); tR.rotation.y = -Math.PI/2; g.add(tR);
                } else {
                    var sL = createSkull(); sL.position.set(-14.9, 6, z); sL.rotation.y = Math.PI/2; g.add(sL);
                    var sR = createSkull(); sR.position.set(14.9, 6, z); sR.rotation.y = -Math.PI/2; g.add(sR);
                }
            }
            g.position.z = zPos + 50; scene.add(g); floorSegments.push(g);
            if(zPos > 50) spawnObstacles(zPos);
        }

        function spawnObstacles(baseZ) {
            for(var i=0; i<5; i++) { 
                var z = baseZ + (i * 22); 
                var r = Math.random();
                if (r < 0.5) {
                    var lane = Math.floor(Math.random()*3)-1;
                    spawnRandomObs(lane, z);
                    [-1,0,1].forEach(l => { 
                        if(l!==lane && Math.random() < 0.2) createDiamond(l, z, 1.5); 
                    });
                } else if (r < 0.65) {
                    var openLane = Math.floor(Math.random()*3)-1;
                    [-1,0,1].forEach(l => {
                        if(l!==openLane) spawnRandomObs(l, z);
                        else {
                            if(Math.random() < 0.8) createDiamond(l, z, 1.5);
                        }
                    });
                } else {
                    [-1,0,1].forEach(l => {
                        if(Math.random() < 0.3) createDiamond(l, z, 1.5);
                    });
                }
            }
        }

        function spawnRandomObs(lane, z) {
            var type = Math.random();
            var o;
            if(type < 0.35) { 
                o = createLog(); obstacles.push({mesh:o, type:'JUMP'}); 
                if(Math.random()<0.8) createDiamond(lane, z, 2.5); // High diamond
            }
            else if(type < 0.65) { 
                o = createBeam(); obstacles.push({mesh:o, type:'SLIDE'}); 
                if(Math.random()<0.8) createDiamond(lane, z, 0.5); // Low diamond
            }
            else { 
                o = createBrokenCart(); obstacles.push({mesh:o, type:'BLOCK'}); 
                // NO DIAMOND HERE
            }
            o.position.set(lane*CONFIG.laneWidth, 0, z);
            scene.add(o);
        }

        function createDiamond(lane, z, yPos) {
            var d = new THREE.Mesh(new THREE.OctahedronGeometry(0.5), MAT.diamond);
            d.position.set(lane*CONFIG.laneWidth, yPos, z);
            coins.push(d); scene.add(d);
        }

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            if (isPaused) return;

            if (!isPlaying && !isGameOver) {
                renderer.render(scene, camera);
                return;
            }

            if (isPlaying && !isGameOver) {
                frameCount++;
                runScore = Math.floor(playerGroup.position.z / 10);
                document.getElementById('run-score-val').innerText = runScore;
                
                var speedIncrease = runScore * 0.0002;
                gameSpeed = Math.min(CONFIG.maxSpeed, CONFIG.startSpeed + speedIncrease);

                playerGroup.position.z += gameSpeed;
                var tx = currentLane * CONFIG.laneWidth;
                playerGroup.position.x += (tx - playerGroup.position.x) * 0.15;

                if (chaserTarget < CONFIG.chaserFarZ) chaserTarget += 0.05;
                chaserOffset += (chaserTarget - chaserOffset) * 0.02;
                chaserGroup.position.z = playerGroup.position.z - chaserOffset;
                chaserGroup.position.x += (playerGroup.position.x - chaserGroup.position.x) * 0.05;
                chaserGroup.position.y = 2 + Math.sin(frameCount * 0.05) * 0.5;

                if (!isJumping && !isSliding) {
                    var s = 0.25 + (gameSpeed * 0.2); 
                    limbs.legL.rotation.x = Math.sin(frameCount*s);
                    limbs.legR.rotation.x = Math.sin(frameCount*s + Math.PI);
                    limbs.armL.rotation.x = Math.sin(frameCount*s + Math.PI);
                    limbs.armR.rotation.x = Math.sin(frameCount*s);
                    playerGroup.position.y = playerY + Math.abs(Math.sin(frameCount*s)*0.1);
                } else {
                    limbs.legL.rotation.x = -0.2; limbs.legR.rotation.x = 0.2;
                    limbs.armL.rotation.x = -2.0; limbs.armR.rotation.x = -2.0;
                }

                var time = Date.now() * 0.005;
                for(var t of torches) {
                    var scale = 1.0 + Math.sin(time + t.offset) * 0.2;
                    t.mesh.scale.set(scale, scale, scale);
                }

                playerY += verticalVel;
                if (playerY > 0) { verticalVel -= CONFIG.gravity; isJumping = true; } 
                else { playerY = 0; verticalVel = 0; isJumping = false; }

                if (isSliding) {
                    playerGroup.rotation.x = -Math.PI/3; playerGroup.position.y = 0.5;
                    slideTimer--;
                    if(slideTimer<=0) { isSliding=false; playerGroup.rotation.x = 0; }
                } else {
                    playerGroup.position.y = playerY;
                }

                camera.position.z = playerGroup.position.z - 12;
                camera.position.x = playerGroup.position.x * 0.5;

                if (playerGroup.position.z > floorSegments[0].position.z + 50) {
                    var old = floorSegments.shift(); scene.remove(old);
                    var lastZ = floorSegments[floorSegments.length - 1].position.z;
                    spawnFloor(lastZ + 50);
                }

                checkCollisions();
                checkCoins();
            } else if (isGameOver) {
                chaserGroup.position.z += 0.2;
                if(chaserGroup.position.z > playerGroup.position.z) chaserGroup.position.z = playerGroup.position.z;
                chaserGroup.position.x = playerGroup.position.x;
                chaserGroup.position.y = 3;
            }

            renderer.render(scene, camera);
        }

        function checkCoins() {
            for(var i=coins.length-1; i>=0; i--) {
                coins[i].rotation.y += 0.05;
                if(coins[i].position.distanceTo(playerGroup.position) < 2.5) {
                    scene.remove(coins[i]); coins.splice(i,1);
                    diamondScore++; 
                    document.getElementById('diamond-val').innerText = diamondScore;
                }
            }
        }

        function checkCollisions() {
            for(var i=0; i<obstacles.length; i++) {
                var obs = obstacles[i];
                if(Math.abs(obs.mesh.position.z - playerGroup.position.z) < 1.0) {
                    if(Math.abs(obs.mesh.position.x - playerGroup.position.x) < 1.5) {
                        var safe = false;
                        if(obs.type === 'JUMP' && playerY > 1.0) safe = true;
                        if(obs.type === 'SLIDE' && isSliding) safe = true;
                        if(!safe) gameOver();
                    }
                }
            }
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            document.getElementById('pause-btn').innerText = isPaused ? '▶' : '||';
        }

        function startGame() {
            initAudio(); 
            document.getElementById('menu-screen').style.display = 'none';
            isPlaying = true;
            isGameOver = false;
            chaserTarget = CONFIG.chaserFarZ;
        }

        function gameOver() {
            isGameOver = true;
            isPlaying = false;
            document.getElementById('menu-screen').style.display = 'flex';
            document.getElementById('game-over-title').style.display = 'block';
            document.getElementById('main-title').style.display = 'none';
            document.getElementById('sub-title').style.display = 'none';
            document.getElementById('controls-panel').style.display = 'none';
            document.getElementById('results-panel').style.display = 'grid';
            document.getElementById('final-run-score').innerText = runScore;
            document.getElementById('final-diamond-score').innerText = diamondScore;
            var btn = document.getElementById('start-btn');
            btn.innerText = "RESURRECT";
            btn.onclick = function() { location.reload(); };
        }

        function handleKey(e) {
            if (e.key === 'p' || e.key === 'P') { togglePause(); return; }
            if(!isPlaying || isPaused) return;
            if (e.key === 'ArrowRight' && currentLane > -1) currentLane--; 
            if (e.key === 'ArrowLeft' && currentLane < 1) currentLane++; 
            if ((e.key === 'ArrowUp' || e.code === 'Space') && !isJumping) verticalVel = CONFIG.jumpForce;
            if (e.key === 'ArrowDown' && !isJumping && !isSliding) { isSliding = true; slideTimer = 40; }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
